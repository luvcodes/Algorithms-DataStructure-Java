# 数组相关笔记

## 杨辉三角
### 杨辉三角 II
题目: LeetCode119: https://leetcode.cn/problems/pascals-triangle-ii/description/   
输入参数目标查找的第几行，返回这行的数组。有一种高级解法，见`YanghuiTriangle2.java`文件的方法三:   
你提出了一个非常好的问题。实际上，这个优化的方法确实只使用了一个一维数组（列表），而不是传统的两行或整个杨辉三角的多行数组。
这种方法可能初看起来有些混淆，因为我们通常想象杨辉三角是由多行构成，但这里的关键在于我们如何巧妙地利用一个数组通过更新的方式来模拟出每一行的效果。

#### 单一数组的行为解释
这段代码中，我们利用了只有一个数组（`row`），它在每次循环的迭代中既代表了“上一行”也在更新后代表了“当前行”。这是通过在迭代中逆序更新数组元素来实现的，
这种更新方式确保在计算当前元素时，利用的是还未更新的“上一行”的值。

#### 操作的具体解释：
- **行的开始（添加1）**：在每次外层循环的开始，我们首先通过 `row.add(1);` 向数组中添加1，这代表每一行的第一个元素，
- 也是上一行结束时的最后一个元素（因为每行的结束元素总是1）。

- **逆序更新**：接下来的逆序更新从当前行的倒数第二个元素开始，一直更新到第二个元素。通过 `row.set(j, row.get(j) + row.get(j - 1))` 来更新：
    - `row.get(j)` 在更新之前代表“上一行”在位置 `j` 的值（因为我们是从行末尾开始向前更新，所以 `j` 位置的值还未被新的值覆盖）。
    - `row.get(j - 1)` 是上一行在位置 `j-1` 的值，这个值在这一轮迭代中没有被修改，所以它是有效的“上一行”的值。

#### 为什么要逆序更新
如果我们正序更新，那么在计算新的 `row[j]` 值时，`row[j-1]` 已经是被更新过的当前行的值，这将导致错误的结果。逆序更新确保了每次使用的都是有效的“上一行”的值，
因为在更新 `row[j]` 之前，`row[j-1]` 还未被当前迭代的任何操作修改。

#### 总结
这种方法非常巧妙地在一个数组内完成了整个杨辉三角的特定行的构建，通过添加0和逆序更新策略，避免了需要额外数组或二维数组结构的需求。
这是一个节省空间同时效率高的算法，非常适合于只需要单行数据的场景。希望这个解释能帮助你理解这个算法是如何工作的！如果还有疑问，欢迎继续讨论。